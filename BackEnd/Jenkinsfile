pipeline {
    agent any

    parameters {
        choice(
            name: 'SERVICE_NAME', 
            choices: ['backend-auth', 'backend-notify', 'backend-post', 'backend-recipe', 'backend-user', 'backend-static', 'gateway', 'gatewayadmin'], 
            description: 'Ch·ªçn Microservice c·∫ßn Build v√† Deploy'
        )
    }

    tools {
        nodejs 'nodejs' 
    }
    
    environment {
        DOCKER_REGISTRY = "catarena" 
        KUBE_NAMESPACE = "default" 
        
        // C·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n
        SERVICE_PATH = "BackEnd/${params.SERVICE_NAME}/" 
        
        // C·∫•u h√¨nh Google Cloud
        GCP_PROJECT_ID = "mobile-project-477308"
        GCP_CLUSTER_NAME = "mobile-cluster"
        GCP_ZONE = "asia-southeast1-a"
        
        // üëá KHAI B√ÅO BI·∫æN ƒê·ªÇ L∆ØU COMMIT HASH (S·∫Ω g√°n gi√° tr·ªã ·ªü stage Init)
        COMMIT_HASH = ""
        IMAGE_TAGGED = ""
    }

    stages { 
        stage('Init & Checkout') {
            steps {
                checkout scm
                script {
                    // üëá L·∫•y 7 k√Ω t·ª± ƒë·∫ßu c·ªßa Git Commit Hash (V√≠ d·ª•: a1b2c3d)
                    env.COMMIT_HASH = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
                    // T·∫°o t√™n image v·ªõi tag unique
                    env.IMAGE_TAGGED = "${DOCKER_REGISTRY}/${params.SERVICE_NAME}:${env.COMMIT_HASH}"
                    
                    echo "üîñ Current Commit Hash: ${env.COMMIT_HASH}"
                    echo "üì¶ Docker Image will be: ${env.IMAGE_TAGGED}"
                }
            }
        }
        
        stage('Run Pipeline') { 
            stages { 
                stage('Scan Dependencies') {
                    steps {
                        script {
                            if (fileExists(env.SERVICE_PATH)) {
                                dir(env.SERVICE_PATH) { 
                                    sh "npm install"
                                    sh "npm audit --audit-level=high || true" 
                                }
                            } else {
                                error "‚ùå Folder not found: ${env.SERVICE_PATH}"
                            }
                        }
                    }
                }
                
                stage('Build & Push Docker') {
                    steps {
                        script {
                            echo "üê≥ Building Docker Image: ${env.IMAGE_TAGGED}"
                            
                            // Build v·ªõi tag l√† Commit Hash
                            sh "docker build -t ${env.IMAGE_TAGGED} ./${env.SERVICE_PATH}"
                            
                            withCredentials([usernamePassword(credentialsId: 'dockerhub', usernameVariable: 'USER', passwordVariable: 'PASS')]) {
                                sh 'echo ${PASS} | docker login -u ${USER} --password-stdin'
                                echo "üöÄ Pushing image..."
                                sh "docker push ${env.IMAGE_TAGGED}"
                            }
                        }
                    }
                }

                stage('Deploy to K8s') {
                    agent {
                        docker {
                            image 'catarena/gcloud-agent:latest'
                        }
                    }
                    steps {
                        withCredentials([googleCredentials(credentialsId: 'k8s-mobile-cluster', variable: 'GCP_KEY_FILE')]) {
                            script {
                                echo "=== DEPLOYING VERSION: ${env.COMMIT_HASH} ==="
                                
                                // 1. Auth GCP
                                sh 'gcloud auth activate-service-account --key-file=$GCP_KEY_FILE'
                                sh "gcloud container clusters get-credentials ${env.GCP_CLUSTER_NAME} --zone ${env.GCP_ZONE} --project ${env.GCP_PROJECT_ID}"
                                
                                def yamlFile = "BackEnd/k8s-deployment/${params.SERVICE_NAME}.yaml"
                                // T√™n deployment (ph·∫£i kh·ªõp trong file yaml)
                                def deploymentName = "${params.SERVICE_NAME}"
                                // T√™n container trong Pod (Th∆∞·ªùng ƒë·∫∑t tr√πng t√™n v·ªõi service/deployment cho d·ªÖ nh·ªõ)
                                // ‚ö†Ô∏è QUAN TR·ªåNG: B·∫°n c·∫ßn m·ªü file YAML xem ph·∫ßn "containers: - name: ???" l√† g√¨.
                                // N·∫øu ch∆∞a bi·∫øt, h√£y gi·∫£ ƒë·ªãnh n√≥ l√† ${params.SERVICE_NAME} ho·∫∑c xem g·ª£i √Ω b√™n d∆∞·ªõi.
                                def containerName = "${params.SERVICE_NAME}" 

                                if (fileExists(yamlFile)) {
                                    try {
                                        // 2. APPLY C·∫§U H√åNH C∆† B·∫¢N (Service, Ingress, ConfigMap...)
                                        // B∆∞·ªõc n√†y v·∫´n c·∫ßn ƒë·ªÉ ƒë·∫£m b·∫£o c·∫•u tr√∫c resource t·ªìn t·∫°i
                                        sh "kubectl apply -f ${yamlFile} --namespace ${env.KUBE_NAMESPACE}"
                                        
                                        // 3. SET IMAGE (KEY POINT üîë)
                                        // L·ªánh n√†y ghi ƒë√® image trong Deployment b·∫±ng image c√≥ tag hash m·ªõi
                                        // C√∫ ph√°p: kubectl set image deployment/<t√™n-deploy> <t√™n-container>=<image-m·ªõi>
                                        echo "üîÑ Updating Deployment to use image: ${env.IMAGE_TAGGED}"
                                        
                                        // L∆∞u √Ω: N·∫øu t√™n container trong file YAML kh√°c t√™n service, l·ªánh n√†y s·∫Ω l·ªói.
                                        // B·∫°n c·∫ßn ch·∫Øc ch·∫Øn t√™n container.
                                        sh "kubectl set image deployment/${deploymentName} ${containerName}=${env.IMAGE_TAGGED} --namespace ${env.KUBE_NAMESPACE}"
                                        
                                        // 4. VERIFY
                                        echo "‚è≥ Waiting for rollout..."
                                        sh "kubectl rollout status deployment/${deploymentName} --namespace ${env.KUBE_NAMESPACE} --timeout=2m"
                                        
                                        echo "‚úÖ Deploy SUCCESS! Version: ${env.COMMIT_HASH}"

                                    } catch (e) {
                                        echo "‚ùå Deployment FAILED: ${e.message}"
                                        echo "üí° G·ª£i √Ω l·ªói 'Container not found': H√£y ki·ªÉm tra file YAML xem 'containers: name' l√† g√¨, c√≥ kh·ªõp v·ªõi bi·∫øn containerName kh√¥ng?"
                                        currentBuild.result = 'FAILURE'
                                        error("Deploy failed")
                                    }
                                } else {
                                    error "‚ùå YAML File not found: ${yamlFile}"
                                }
                            }
                        }   
                    }
                }
            } 
        } 
    }
    post {
        always {
            script {
                echo "üßπ Cleaning up..."
                sh "docker rmi ${env.IMAGE_TAGGED} || true"
            }
        }
    }
}