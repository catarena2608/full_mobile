pipeline {
    agent any

    parameters {
        choice(
            name: 'SERVICE_NAME', 
            choices: ['backend-auth', 'backend-notify', 'backend-post', 'backend-recipe', 'backend-user', 'backend-static', 'gateway', 'gatewayadmin'], 
            description: 'Ch·ªçn Microservice c·∫ßn Build v√† Deploy'
        )
    }

    tools {
        nodejs 'nodejs' 
    }
    
    environment {
        DOCKER_REGISTRY = "catarena" 
        KUBE_NAMESPACE = "default" 
        
        // C·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n
        SERVICE_PATH = "BackEnd/${params.SERVICE_NAME}/" 
        
        // Image lu√¥n l√† latest
        IMAGE_NAME = "${DOCKER_REGISTRY}/${params.SERVICE_NAME}:latest"
    }

    stages { 
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Run Pipeline') { 
            stages { 
                stage('Scan Dependencies') {
                    steps {
                        script {
                            if (fileExists(env.SERVICE_PATH)) {
                                dir(env.SERVICE_PATH) { 
                                    sh "npm install"
                                    sh "npm audit --audit-level=high || true" 
                                }
                            } else {
                                error "Folder not found: ${env.SERVICE_PATH}"
                            }
                        }
                    }
                }
                
                stage('Build & Push Docker') {
                    steps {
                        script {
                            // Build tag latest
                            sh "docker build -t ${IMAGE_NAME} ./${env.SERVICE_PATH}"
                            
                            withCredentials([usernamePassword(credentialsId: 'dockerhub', usernameVariable: 'USER', passwordVariable: 'PASS')]) {
                                sh 'echo ${PASS} | docker login -u ${USER} --password-stdin'
                                echo "Pushing image: ${IMAGE_NAME}"
                                sh "docker push ${IMAGE_NAME}"
                            }
                        }
                    }
                }

                // =========================================================
                // üëá PH·∫¶N DEPLOY K8S ƒê√É S·ª¨A THEO Y√äU C·∫¶U
                // =========================================================
                stage('Deploy to K8s') {
                    agent {
                        docker {
                            image 'catarena/gcloud-agent:latest' 
                        }
                    }
                    steps {
                        withCredentials([file(credentialsId: 'gcp-k8s-developer', variable: 'GCP_KEY_FILE')]) {
                            script {
                                // 1. Auth GCP
                                sh 'gcloud auth activate-service-account --key-file=$GCP_KEY_FILE'
                                sh 'gcloud container clusters get-credentials mobile-cluster --zone asia-northeast1 --project k8s-cluster-477721'
                                
                                // ƒê·ªãnh nghƒ©a file YAML
                                def yamlFile = "BackEnd/k8s-deployment/${params.SERVICE_NAME}.yaml"
                                // T√™n deployment ƒë·ªÉ check status (ph·∫£i kh·ªõp v·ªõi metadata.name trong file yaml)
                                def deploymentName = "${params.SERVICE_NAME}-deployment"

                                if (fileExists(yamlFile)) {
                                    try {
                                        echo "=== DEPLOYING: ${params.SERVICE_NAME} ==="

                                        // 2. X√ìA C≈® (Hard Reset)
                                        // D√πng -f yamlFile ƒë·ªÉ K8s t·ª± ƒë·ªçc t√™n resource c·∫ßn x√≥a t·ª´ file, ch√≠nh x√°c h∆°n l√† ƒëo√°n t√™n
                                        echo "üóëÔ∏è Deleting old resources..."
                                        sh "kubectl delete -f ${yamlFile} --namespace ${env.KUBE_NAMESPACE} --ignore-not-found=true"
                                        
                                        // 3. APPLY M·ªöI
                                        // Ch·ªù 5s ƒë·ªÉ K8s d·ªçn d·∫πp Pod c≈© s·∫°ch s·∫Ω
                                        sleep 5
                                        echo "üöÄ Applying new configuration..."
                                        sh "kubectl apply -f ${yamlFile} --namespace ${env.KUBE_NAMESPACE} --record"
                                        
                                        // 4. VERIFY
                                        echo "‚è≥ Waiting for rollout..."
                                        sh "kubectl rollout status deployment/${deploymentName} --namespace ${env.KUBE_NAMESPACE} --timeout=2m"
                                        
                                        echo "‚úÖ Deploy SUCCESS!"

                                    } catch (e) {
                                        echo "‚ùå Deployment FAILED: ${e.message}"
                                        currentBuild.result = 'FAILURE'
                                        error("Deploy failed")
                                    }
                                } else {
                                    error "YAML File not found at: ${yamlFile}"
                                }
                            }
                        }   
                    }
                }
            } 
        } 
    }
    post {
        always {
            script {
                sh "docker rmi ${env.IMAGE_NAME} || true"
            }
        }
    }
}